import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from "@nestjs/common";
import { CreateLessonDto } from "./dto/create-lesson.dto";
import { UpdateLessonDto } from "./dto/update-lesson.dto";
import * as fs from "fs";
import { PrismaService } from "src/core/prisma/prisma.service";
import { CloudinaryService } from "src/core/cloudinary/cloudinary.service";

@Injectable()
export class LessonService {
  constructor(
    private prisma: PrismaService,
    private readonly cloudinaryService: CloudinaryService
  ) {}

  // üß© T·∫°o b√†i h·ªçc m·ªõi
  async create(
    dto: CreateLessonDto,
    instructorId?: number,
    video?: Express.Multer.File
  ) {
    // üß© Ki·ªÉm tra chapter t·ªìn t·∫°i v√† thu·ªôc kh√≥a h·ªçc c·ªßa gi·∫£ng vi√™n
    const chapter = await this.prisma.chapter.findUnique({
      where: { id: dto.chapterId },
      include: { course: true },
    });

    if (!chapter || chapter.course.instructorId !== instructorId) {
      throw new NotFoundException(
        "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng ho·∫∑c kh√¥ng c√≥ quy·ªÅn truy c·∫≠p"
      );
    }

    // üß© Ki·ªÉm tra tr√πng orderIndex trong c√πng 1 chapter
    if (dto.orderIndex !== undefined && dto.orderIndex !== null) {
      const existingLesson = await this.prisma.lesson.findFirst({
        where: {
          chapterId: dto.chapterId,
          orderIndex: dto.orderIndex,
        },
      });

      if (existingLesson) {
        throw new BadRequestException(
          `Th·ª© t·ª± ${dto.orderIndex} ƒë√£ t·ªìn t·∫°i trong ch∆∞∆°ng n√†y`
        );
      }
    }

    // üß© Ki·ªÉm tra c√≥ video kh√¥ng
    if (!video) throw new NotFoundException("C·∫ßn ph·∫£i c√≥ file video");

    // üß© Upload video l√™n Cloudinary
    let videoUrl: string | null = null;

    const uploaded = await this.cloudinaryService.uploadFile(
      video,
      "lessons",
      "video"
    );
    videoUrl = uploaded.secure_url;

    // üß© T·∫°o b√†i h·ªçc
    return this.prisma.lesson.create({
      data: {
        title: dto.title,
        content: dto.content,
        videoUrl,
        orderIndex: dto.orderIndex ?? 0,
        chapterId: dto.chapterId,
      },
    });
  }

  // üß© L·∫•y t·∫•t c·∫£ b√†i h·ªçc
  async findAll() {
    return this.prisma.lesson.findMany({
      orderBy: { createdAt: "desc" },
    });
  }

  // üß© L·∫•y b√†i h·ªçc theo ID
  async findOne(id: number) {
    const lesson = await this.prisma.lesson.findUnique({ where: { id } });
    if (!lesson) throw new NotFoundException("Kh√¥ng t√¨m th·∫•y b√†i h·ªçc");
    return lesson;
  }

  // üß© L·∫•y danh s√°ch b√†i h·ªçc theo kh√≥a h·ªçc c·ªßa gi·∫£ng vi√™n
  async getLessonsByCourse(courseId: number, instructorId: number) {
    const course = await this.prisma.course.findFirst({
      where: { id: courseId, instructorId },
    });

    if (!course)
      throw new ForbiddenException(
        "B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p v√†o kh√≥a h·ªçc n√†y"
      );

    const lessons = await this.prisma.lesson.findMany({
      where: { chapter: { courseId } },
      orderBy: { orderIndex: "asc" },
      include: {
        quizzes: {
          include: {
            _count: { select: { questions: true } },
          },
        },
        chapter: true,
      },
    });

    return {
      message: "L·∫•y danh s√°ch b√†i h·ªçc th√†nh c√¥ng",
      data: lessons,
    };
  }

  // üß© C·∫≠p nh·∫≠t b√†i h·ªçc
  async update(
    id: number,
    dto: UpdateLessonDto,
    instructorId: number,
    video?: Express.Multer.File
  ) {
    const existing = await this.prisma.lesson.findUnique({
      where: { id },
      include: { chapter: { include: { course: true } } },
    });

    if (!existing) throw new NotFoundException("Kh√¥ng t√¨m th·∫•y b√†i h·ªçc");
    if (existing.chapter.course.instructorId !== instructorId)
      throw new ForbiddenException("B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t b√†i h·ªçc n√†y");

    // üß© Ki·ªÉm tra tr√πng orderIndex trong c√πng chapter
    if (
      dto.orderIndex !== undefined &&
      dto.orderIndex !== existing.orderIndex
    ) {
      const duplicate = await this.prisma.lesson.findFirst({
        where: {
          chapterId: existing.chapterId,
          orderIndex: dto.orderIndex,
          NOT: { id },
        },
      });

      if (duplicate) {
        throw new ConflictException(
          `Th·ª© t·ª± ${dto.orderIndex} ƒë√£ t·ªìn t·∫°i trong ch∆∞∆°ng n√†y`
        );
      }
    }

    // üß© Upload video m·ªõi (n·∫øu c√≥)
    let videoUrl = existing.videoUrl;
    if (video) {
      // N·∫øu mu·ªën x√≥a video c≈©, c√≥ th·ªÉ th·ª±c hi·ªán ·ªü ƒë√¢y
      // if (existing.videoUrl) await this.cloudinaryService.deleteFile(existing.videoUrl);

      const uploaded = await this.cloudinaryService.uploadFile(
        video,
        "lessons",
        "video"
      );
      videoUrl = uploaded.secure_url;
    }

    // üß© C·∫≠p nh·∫≠t b√†i h·ªçc
    const updated = await this.prisma.lesson.update({
      where: { id },
      data: {
        title: dto.title ?? existing.title,
        content: dto.content ?? existing.content,
        orderIndex: dto.orderIndex ?? existing.orderIndex,
        videoUrl,
      },
    });

    return {
      message: "C·∫≠p nh·∫≠t b√†i h·ªçc th√†nh c√¥ng",
      data: updated,
    };
  }

  // üß© X√≥a b√†i h·ªçc
  async remove(id: number) {
    const existing = await this.prisma.lesson.findUnique({ where: { id } });
    if (!existing) throw new NotFoundException("Kh√¥ng t√¨m th·∫•y b√†i h·ªçc");

    return this.prisma.lesson.delete({ where: { id } });
  }
}
